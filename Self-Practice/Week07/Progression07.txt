*///// 1.DOM Node /////*\
DOM (Document Object Model) คือโครงสร้างต้นไม้ (Tree Structure) ของ HTMLแต่ละส่วนของ HTML เช่น <div>, <p>, ข้อความ หรือคอมเมนต์
จะถูกแปลงเป็น “Node” (โหนด) ที่มีชนิดแตกต่างกัน
หลักการ
Browser จะ parse HTML แล้วแปลงทุกอย่างเป็น node object:
Ex.<body>
    Hello
   </body>
จะกลายเป็น:
BODY (ELEMENT_NODE)
TEXT("Hello") (TEXT_NODE)

Node Type	        ค่าตัวเลข	ความหมาย
Node.ELEMENT_NODE	 1	      โหนดที่เป็น element เช่น <div> <p>
Node.ATTRIBUTE_NODE	 2	      โหนดที่เป็น attribute เช่น id, class
Node.TEXT_NODE	     3	      โหนดข้อความ (ระหว่างแท็ก)
Node.COMMENT_NODE	 8	      โหนดคอมเมนต์ <!-- comment -->
Node.DOCUMENT_NODE	 9	      โหนดเอกสาร (รากของ DOM Tree)
///
console.log(document.body)
console.log(document.body.nodeName)
console.log(document.body.nodeType)
console.log(document.body.nodeValue)

if (document.body.nodeType === Node.ELEMENT_NODE)
  console.log(`body is an element node type`)
if (document.body.nodeType === Node.ATTRIBUTE_NODE)
  console.log(`body is an attribute node type`)
if (document.body.nodeType === Node.TEXT_NODE)
  console.log(`body is a text node type`)
///

Description
1.)document.body → เข้าถึง <body> element ของหน้า HTML
2.).nodeName → คืนชื่อของ node เช่น "BODY"
3.).nodeType → บอกชนิดของ node (เป็นตัวเลข)
4.).nodeValue → ใช้กับ TextNode หรือ Attribute เพื่ออ่านค่าข้อความ


*//// 1.1 ฟังก์ชันตรวจชนิด Node
function checkNodeType(node) {
  console.log("Node Name:", node.nodeName);
  console.log("Node Type:", node.nodeType);

  switch (node.nodeType) {
    case Node.ELEMENT_NODE:
      console.log("This is an ELEMENT NODE.");
      break;
    case Node.ATTRIBUTE_NODE:
      console.log("This is an ATTRIBUTE NODE.");
      break;
    case Node.TEXT_NODE:
      console.log("This is a TEXT NODE.");
      break;
    case Node.COMMENT_NODE:
      console.log("This is a COMMENT NODE.");
      break;
    case Node.DOCUMENT_NODE:
      console.log("This is a DOCUMENT NODE.");
      break;
    default:
      console.log("Unknown node type.");
  }
}
const bodyElement = document.body;
checkNodeType(bodyElement);

Description
1.)ฟังก์ชันนี้รับ node มา แล้วตรวจชนิดด้วย nodeType
2.)ใช้ switch-case เพื่อแสดงผลว่า node เป็นอะไร
3.)เช่น <div> = ELEMENT_NODE, <!-- comment --> → COMMENT_NODE

*///// 2. การเข้าถึงลูก Node และ Element (childNodes vs children) /////*
- DOM Tree มี node ทุกชนิดในลำดับจริงของ HTML
- childNodes จะเก็บทุกอย่าง (รวม space และข้อความ)
- children จะกรองเฉพาะ node ประเภท ELEMENT เท่านั้น
///
const divElement = document.getElementById("exampleElement")
// childNodes
const divChildNodes = divElement.childNodes
console.log(`length: ${divElement.childNodes.length}`)
divChildNodes.forEach((child) => {
  console.log(child.nodeName)
  console.log(child.nodeType)
  console.log(child.nodeValue)
})
// children
const divChildren = divElement.children
console.log(`length: ${divElement.children.length}`)
Array.from(divChildren).forEach((child) => {
  console.log(child.nodeName)
  console.log(child.nodeType)
  console.log(child.nodeValue)
})
///

Description
childNodes = คืน NodeList ที่รวมลูกทุกชนิด (Text, Comment, Element)
children = คืนเฉพาะ Element Node เท่านั้น
ถ้า <div> มีข้อความ, คอมเมนต์, และ <span> จะได้จำนวนต่างกัน

/// ตัวอย่างที่ 2 
<div id="exampleElement" style="font-size: 10pt">
  <!-- this is a comment node -->
  This is some <span style="display: none">hidden</span> text content.
</div>

ผลที่ได้
childNodes.length = 5 (รวม comment, text, span ฯลฯ)
children.length = 1 (เฉพาะ <span>)

*///// 3. การสร้าง Element และ Attribute (Create + Append + Get) /////*
- DOM สร้าง node ใหม่ใน memory ก่อน แล้ว append เข้ากับ tree
- เมื่อ append -> browser render บนหน้าทันที

///
const divElement = document.getElementById("subject")
const pElement = document.createElement("p")
pElement.setAttribute("id", "int141")
pElement.setAttribute("style", "color:red")
pElement.setAttribute("name", "core")

const pText = document.createTextNode("INT141")
pElement.appendChild(pText)
divElement.appendChild(pElement)

console.log(pElement.getAttribute("id")) // int141
console.log(pElement.attributes[0]) // id="int141"
console.log(pElement.attributes[0].ownerElement) // <p id="int141">INT141</p>
///

Description
1.)document.createElement("p") → สร้าง <p> ใหม่ในหน่วยความจำ
2.)setAttribute(name, value) → เพิ่ม attribute ให้ element เช่น id, style
3.)createTextNode("INT141") → สร้าง node ข้อความ
4.)appendChild() → ผูก text เข้ากับ <p> แล้วผูก <p> เข้ากับ <div>
5.).getAttribute("id") → อ่านค่าของ attribute
6.).attributes → คืน collection ของ attribute ทั้งหมดของ element

*///// 4. การเข้าถึงข้อความใน Element (innerHTML / innerText / textContent) /////*

///
let el = document.getElementById("demo")
console.log(el.innerHTML)
console.log(el.innerText)
console.log(el.textContent)

const pElement = document.createElement("p")
pElement.innerText = "<i>Sample Content</i>"
document.body.appendChild(pElement)
///

Property	อ่าน/เขียน	  แปล HTML tag	   รวม Hidden Text ไหม
innerHTML	 ใช่	      แปล HTML	       รวม
innerText	 ใช่	      แสดงเป็นข้อความ	 ข้าม Hidden
textContent	 ใช่	      แสดงข้อความตรงๆ	รวม Hidden

/// ตัวอย่าง
<div id="demo">
  <b>Hello</b>
  <span style="display:none">hidden</span>
  world
</div>
///
innerHTML	 <b>Hello</b><span style="display:none">hidden</span>world
innerText	 Hello world
textContent	 Hello hidden world

*///// 5. การเชื่อมโยงความสัมพันธ์ (Parent–Child–Sibling) /////*
DOM ทุก node มี reference ที่เชื่อมถึงกัน
 parentElement = ลูกทั้งหมด (children)
 previousElementSibling = พี่
 nextElementSibling = น้อง
///
let el = document.getElementById("drink")
const allDrinks = el.children
Array.from(allDrinks).forEach((drink) => console.log(drink))

let teaDrink = allDrinks[1]
console.log(teaDrink.textContent)

console.log(teaDrink.previousElementSibling)
console.log(teaDrink.nextElementSibling)
console.log(teaDrink.parentElement)
///

Description
1).children = คืนลูกทั้งหมด (เฉพาะ element node)
2.)[1] = เข้าถึง <li>Tea</li>
3.).previousElementSibling = <li>Coffee</li>
4.).nextElementSibling = <li>Chocolate</li>
5.).parentElement = <ul id="drink">

